---
title: "Project"
author: "Olga Potanina"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(openxlsx)
library (tidyverse)
library(vegan)
library(broom) 
library (flextable)
```

# Предобработка данных

## Чтение, слияние, редактирование исходных датасетов

-   Загрузка датасетов с информацией о здоровых людях (`info_healthy`) и пациентах с СРК (`info_ibs`)

```{r, message=FALSE}

info_healthy <- read_xlsx ("data/raw/final_health_statistic.xlsx")
info_ibs <- read_xlsx ("data/raw/final_ibs_141_statistic.xlsx")

```

-   Сравнение переменных в `info_healthy` и `info_ibs`

```{r, echo=FALSE}

cat (
c ("Уникальные переменные в info_ibs:", info_ibs %>% 
  select (- c (intersect (names(info_healthy), names(info_ibs)))) %>% colnames()),
c ("Уникальные переменные в info_healthy:", info_healthy %>% 
  select (- c (intersect (names(info_ibs), names(info_healthy)))) %>% colnames()), 
sep = "\n") 

```

#### combined_info

-   Объединение `info_healthy` и `info_ibs` в единый датасет `combined_info` c редактированием содержимого

```{r combined_info, message=FALSE}

combined_info <- info_healthy %>% 
  bind_rows(info_ibs) %>%
  mutate (
    BMI_min = ifelse (is.na (BMI_min), round (Weight_min /(Height_max/100 * Height_max/100), 2), BMI_min),
    BMI_max = ifelse (is.na (BMI_max), round (Weight_max /(Height_min/100 * Height_min/100), 2), BMI_max)
    ) %>% 
  unite("BMI_range", BMI_min, BMI_max, sep = "-", na.rm = TRUE) %>%
  unite ("Age_range", Age_min, Age_max, sep = "-", na.rm = TRUE) %>%
  mutate(
    Age_range = case_when(
      Age_range == "18-40" | Age_range == "23-28" | Age_range == "16-42" | Age_range == "21-43" ~ "16-43",
      Age <= 43 ~ "16-43",
      Age > 43 ~ "> 43",
      TRUE ~ NA_character_), #удалена группа 28-54
    research_ID = sub ("research_", "", research_ID),
    research_ID = case_when(
      research_ID == 0 ~ 1,
      research_ID == 1 ~ 2,
      research_ID == 2 ~ 3,
      research_ID == 3 ~ 4,
      research_ID == 4 ~ 5, 
      research_ID == 6 ~ 6, 
      research_ID == 7 ~ 7), 
    patient_ID = row_number(),
    Sex = ifelse (Sex == "mixed", NA, Sex),
    Smoking = sub ("never", "Never",  Smoking),
    Smoking = case_when(
      Smoking == "No" ~ "No",
      Smoking == "Never" ~ "No",
      Smoking == "Rarely (a few times/month)" ~ "Yes", #5 чел.
      Smoking == "Occasionally (1-2 times/week)" ~ "Yes",  #3 чел.
      Smoking == "Regularly (3-5 times/week)" ~ "Yes",  #1 чел.
      Smoking == "Daily" ~ "Yes"), #7 чел.
    Alcohol = sub ("rarely", "Rarely", Alcohol),
    Alcohol = ifelse(Alcohol == "Regularly (3-5 times/week)"|
                       Alcohol == "Daily", #3 чел.
                     "Regularly (3-7 times/week)", Alcohol),
    Antibiotics_usage = case_when(
      Antibiotics_usage == "Month" | Antibiotics_usage == ~ "3 months" |
        Antibiotics_usage == "6 months" ~ "1-6 months",
        #2 чел. больных Month, 0 чел. здоровых 3 months, 0 чел. здоровых для 6 months
      Antibiotics_usage == "Year" | Antibiotics_usage == "Not use"  ~ 
        "12 months/Not use"), # 0 чел. из здоровых для 6-12 months, 0 чел. больных для Not use
    Hygiene = case_when(
      Hygiene == "Occasionally (1-2 times/week) cosmetics" ~ "Occasionally cosmetics (1-2 times/week)",
      Hygiene == "Rarely (a few times/month) cosmetics" ~ "Rarely cosmetics (a few times/month)",
      TRUE ~ Hygiene),
    Hygiene = case_when(
      Hygiene == "Daily cosmetics"|Hygiene == "Regularly cosmetics (3-5 times/week)" ~ "Regularly (3-7 times/week)", #0 чел. больных  для 3-5 times/week
      Hygiene == "Occasionally cosmetics (1-2 times/week)" | Hygiene == "Rarely cosmetics (a few times/month)" ~ "Occasionally (a few-8 times/month)",
      #только 2 чел. больных для 1-2 times/week
      Hygiene == "Never cosmetics" ~ "Never"),
    Physical_activity = sub ("regularly", "Regularly",  Smoking),
    BMI = ifelse (is.na(Weight_kg), BMI, Weight_kg/ (Height_cm/100 * Height_cm/100)),
    BMI_range = ifelse(BMI_range == "", NA, BMI_range),
    BMI_category = case_when(
      BMI_range == "18-25" ~ "normal/overweight",
      BMI_range == "19.21-29.29" ~ "normal/overweight",
      BMI_range == "20.6-29.6" ~ "normal/overweight",
      BMI_range == "21.74-28.38" ~ "normal/overweight",
      BMI_range == "18.5-30.8" ~ "normal/overweight", #немного больше 30
      BMI < 18.5 ~ "underweight",
      BMI >= 18.5 & BMI < 30 ~ "normal/overweight",
      BMI >= 30 ~ "obese")
    ) %>% 
  rename ("Cosmetics" = Hygiene ) %>% 
  
  mutate_if (is.character, as.factor) %>% 
  
  select(-c(
    Instrument, # unique (combined_info$Instrument) = "Illumina MiSeq" 
    Isolation_source, # unique (combined_info$Isolation_source) = "faeces" 
    Assay_type, # unique (combined_info$Assay_type) = "AMPLICON"
    Target_gene, # unique (combined_info$Target_gene) = "16S"
    Main_Disease, # unique (combined_info$Main_Disease) = NA (for healthy), 141 (for ibs)
    Drugs, # unique (combined_info$Drugs) = NA
    Social_status, # unique (combined_info$Social_status) =  NA, urban 
    Weight_kg, Height_cm, Weight_min, Weight_max, Height_min, Height_max, BMI_range, #использованы для создания BMI_category, уменьшения количества NA в BMI
    BMI, # NA у всех здоровых
    Birth_Year, # имеются значения только в тех случаях, где возраст уже известен
    Pets_type # только cat и NA
  ))

rm (info_healthy, info_ibs)
summary (combined_info)

```

-   Таблица с количеством субъектов (n) в зависимости от исследования, даты, наличия/отсутствия СРК

```{r, message=FALSE}

combined_info %>% 
  select (research_ID, Country, Seq_date, Health_state) %>% 
  group_by(research_ID, Country, Seq_date, Health_state) %>% 
  summarise(n = n()) %>% 
  flextable() %>% theme_box() %>% 
  merge_v(c ("research_ID", "Country", "Seq_date", "Health_state")) %>% 
  align(align = "center", part = "all")

```

#### tbl_summary of combined_info

```{r, message=FALSE}

library(gtsummary)

combined_info %>% 
  select(! c(patient_ID,
              Diet_duration, Additive_usage, Diet_type #у всех здоровых данные переменные = NA
              )) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Health_state) %>%
  add_p()

```

-   Загрузка датасетов с данными о микробиоме здоровых людей (`bacteria_healthy`) и пациентов с СРК (`bacteria_ibs`) и их объединение в `combined_bacteria`

```{r combined_bacteria, message = FALSE}

bacteria_healthy <- read_csv("data/raw/final_bacteria_health.csv")
bacteria_ibs <- read_csv("data/raw/final_bacteria_ibs_141.csv")

combined_bacteria <- bacteria_healthy %>% 
  bind_rows (bacteria_ibs) %>% 
  mutate(patient_ID = row_number())

rm (bacteria_healthy, bacteria_ibs)

```

-   Объединение `combined_bacteria` и `combined_info` в `data_wide`

```{r data_wide, message=FALSE}

data_wide <- combined_info %>% 
  left_join (combined_bacteria)

```

 

## Оценка доли NA и нулевых значений

-   Оценка доли NA в переменных `data_wide`

```{r}

data_wide %>% 
  select (where (function(x) sum (is.na(x))/ nrow(data_wide) * 100 > 0)) %>% 
  sapply (function(x) sum (is.na(x))/ nrow(data_wide) * 100) %>% round(1) %>% 
  as.data.frame() %>% 
  rename(NA_percentage = ".") %>% 
  mutate (
    "Number of people with known data" = round (nrow(data_wide) - NA_percentage/100 * nrow(data_wide)),
    NA_percentage = paste (NA_percentage, "%", sep = " ")
    ) %>% 
  arrange(desc (NA_percentage)) %>% 
  rownames_to_column() %>% 
  as_tibble() %>% flextable()

```

-   Рассчитаем процент не NA и не 0 данных по колонкам широкого формата

```{r calculate percentage for each variable}

# Устанавливаем порог процента 
threshold_percent <- 95 
 
# Функция для вычисления процента записей, не равных NA и не равных 0, для каждой колонки 
calculate_percentage <- function(col) { 
  sum(!is.na(col) & col != 0) / length(col) * 100 
} 
 
# Применяем функцию к каждой колонке в датасете 
percentage_non_zero_non_na <- sapply(data_wide[, -1], calculate_percentage) 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  column = names(percentage_non_zero_non_na), 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% 
  arrange(desc(percentage))
 
# Отфильтровываем колонки, у которых процент записей менее threshold_percent% 
filtered_columns <- result_df_sort[result_df_sort$percentage < threshold_percent, ]

# Сохраним датасет в excel для дальнейшего анализа
write.xlsx(filtered_columns, 
           file = "data/originals/percentage_by_vars.xlsx")

# Перезапись data_wide с выбором колонок с процентом NA/0 менее threshold_percent 
data_wide <- data_wide %>% 
  select (row.names(filtered_columns), research_ID)

rm (calculate_percentage, result_df_sort)

```

-   Рассчитаем процент не NA и не 0 данных по форматированному `patient_ID`

```{r}
# Устанавливаем порог процента 
threshold_percent <- 95
 
# Рассчитываем процент значений, не являющихся NA и не равных 0, для каждого пациента 
percentage_non_zero_non_na <- rowMeans(!is.na(data_wide) & data_wide != 0, na.rm = TRUE) * 100 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  patient_id = data_wide$patient_ID, 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% arrange(desc(percentage))

# Отфильтровываем пациентов, у которых процент значений менее threshold_percent% 
filtered_patients <- result_df_sort[result_df_sort$percentage < threshold_percent, ] 

# Сохраним датасет в excel для дальнейшего анализа 
write.xlsx(filtered_patients,
           file = "data/originals/percentage_by_patient.xlsx") 

# Перезапись data_wide с удалением строк с процентом NA/0 более threshold_percent 
data_wide <- data_wide %>% 
  slice (filtered_patients$patient_id) #при threshold_percent = 95%, изменения data_wide не происходит, так как нет пациентов с процентом NA/0 более 95%

rm (percentage_non_zero_non_na, result_df_sort)

```


-   Удалениe из `data_wide` колонок и строк с процентом NA/0 более threshold_percent 

```{r}

data_wide <- data_wide %>% 
  select (patient_ID, any_of (colnames(combined_info)), everything()) %>% 
  arrange(patient_ID)

```

 

## Поиск "таксонов одного исследования"

### Среднее содержание G_таксонов, которые были обнаружены только в одном исследовании

```{r}

G_only_one <- data_wide %>% 
  select (research_ID, ends_with("_G")) %>%
  add_column(n = 1) %>% #колонка для дальнейшего подсчёта количества субъектов в исследовании
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #выбираем таксоны, которые обнаружены только в одном исследовании 
  mutate (across(-c(1:2),
                 function(x) x/n))

G_only_one

```
 
- Определение процента людей, у которых данные таксоны не обнаружены () 

```{r, include=FALSE}

G_taxon <- 'Ellin517_G'
res_ID <- 7

data_wide %>% 
  select (research_ID, G_taxon) %>%
  filter (research_ID == res_ID) %>% 
  summarise(across (-1,
              function (x) sum (x==0)/nrow (.) * 100)) %>% 
  rename ("Taxon_zero_percentage, %" = G_taxon) 

# CM1G08_G - 73,6% нулей
# Cladosporium_G - 94,0% нулей
# Lentimonas_G - 94,0% нулей
# Micromonospora_G - 93,2% нулей
# Pseudosphingobacterium_G - 93,2% нулей 
# Schizothrix LEGE 07164_G - 92,7% нулей 
# Talaromyces_G - 92,7% нулей 
# Rs-D38 termite group_G - 91,9% нулей 
# Kabatiella_G - 90,6% нулей 
# Anaerolineaceae UCG-001_G - 89,5% нулей 
# Iamia_G - 88,2% нулей 
# Thiohalocapsa_G - 87,9% нулей 
# Ellin517_G - 75,1% нулей 

rm (G_taxon, res_ID)
```

### Среднее содержание F_таксонов, которые были обнаружены только в одном исследовании

```{r}

data_wide %>% 
  select (research_ID, ends_with("_F")) %>%
  add_column(n = 1) %>% #колонка для дальнейшего подсчёта количества субъектов в исследовании
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #выбираем таксоны, которые обнаружены только в одном исследовании 
  mutate (across(-c(1:2),
                 function(x) x/n))
  
```

- Определение процента людей, у которых данные таксоны не обнаружены () 

```{r, include=FALSE}

F_taxon <- 'Iamiaceae_F'
res_ID <- 1

data_wide %>% 
  select (research_ID, F_taxon) %>%
  filter (research_ID == res_ID) %>% 
  summarise(across (-1,
              function (x) sum (x==0)/nrow (.) * 100)) %>% 
  rename ("Taxon_zero_percentage, %" = F_taxon) 

# Didymellaceae_F - 44,4% нулей
# Cladosporiaceae_F - 36,1% нулей
# Trichocomaceae_F - 22,2% нулей
# type III_F - 30,4% нулей
# 09D2Z48_F - 23,9% нулей
# Aureobasidiaceae_F - 0% нулей 
# Iamiaceae_F - 2,2% нулей

rm (F_taxon, res_ID)

```

### Среднее содержание O_таксонов, которые были обнаружены только в одном исследовании

```{r}

data_wide %>% 
  select (research_ID, ends_with("_O")) %>%
  add_column(n = 1) %>% #колонка для дальнейшего подсчёта количества субъектов в исследовании
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #выбираем таксоны, которые обнаружены только в одном исследовании 
  mutate (across(-c(1:2),
                 function(x) x/n))
  
```

- Определение процента людей, у которых данные таксоны не обнаружены () 

```{r, include=FALSE}

O_taxon <- 'Candidatus Abawacabacteria_O'
res_ID <- 1

data_wide %>% 
  select (research_ID, O_taxon) %>%
  filter (research_ID == res_ID) %>% 
  summarise(across (-1,
              function (x) sum (x==0)/nrow (.) * 100)) %>% 
  rename ("Taxon_zero_percentage, %" = O_taxon) 

# Hypocreales_O - 41,7% нулей
# Pleosporales_O - 41,7% нулей
# Candidatus Abawacabacteria_O - 52,2% нулей
# Candidatus Peregrinibacteria_O - 52,2% нулей
# Capnodiales_O - 33,3% нулей
# Candidatus Terrybacteria_O - 39,1% нулей
# Eurotiales_O - 39,1% нулей
# Dothideales_O - 0% нулей
# eub62A3_O - 15,2% нулей
# LD1-PA32_O - 2,2% нулей

rm (O_taxon, res_ID)

```

### Среднее содержание C_таксонов, которые были обнаружены только в одном исследовании

```{r}

data_wide %>% 
  select (research_ID, ends_with("_C")) %>%
  add_column(n = 1) %>% #колонка для дальнейшего подсчёта количества субъектов в исследовании
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #выбираем таксоны, которые обнаружены только в одном исследовании 
  mutate (across(-c(1:2),
                 function(x) x/n))
  
```

- Определение процента людей, у которых данные таксоны не обнаружены () 

```{r, warning=FALSE, include=FALSE}

С_taxon <- 'Dothideomycetes_C'
res_ID <- 2

data_wide %>% 
  select (research_ID, С_taxon) %>%
  filter (research_ID == res_ID) %>% 
  summarise(across (-1,
              function (x) sum (x==0)/nrow (.) * 100)) %>% 
  rename ("Taxon_zero_percentage, %" = С_taxon) 

# WWE3_C - 74,4% нулей
# Eurotiomycetes_C - 19,4% нулей 
# Dothideomycetes_C - 0% нулей 

rm (С_taxon, res_ID)

```
### Среднее содержание P_таксонов, которые были обнаружены только в одном исследовании

**P_таксонов, которые были обнаружены только в одном исследовании, нет**

 
 
## data_wide (not batched)
`
```{r}

data_wide <- data_wide %>% 
  select (!colnames (G_only_one) [- c (1,2)]) #удаление G_таксонов, которые обнаружены только в одном исследовании (все они в этом исследовании встречались редко - до 25% людей)

data_wide_not_batched <- data_wide  

write_rds(data_wide, 
          file = "data/originals/data_wide_not_batched.rds")

```

# Кластеризация

## Кластеризация родов (G-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 4 #количество кластеров

library(cluster)
library(factoextra)

G_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- G_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- G_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = G_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по содержанию G-таксонов до batch-коррекции")

```

### Определение оптимального количества кластеров

-   методом локтя

```{r}

G_scaled %>% 
fviz_nbclust(FUN = hcut, method = "wss") 

```

-   с помощью коэффициента силуэта

```{r}

G_scaled %>% 
  fviz_nbclust(FUN = hcut, method = "silhouette") 

```

### DBSCAN

-   определением оптимального размера радиуса (eps)

```{r}

G_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=37, col = "red", lty = 2)

```

```{r}

G_scaled %>%
dbscan::dbscan(eps = 37, # радиус
       minPts = 20) %>%  # мин. количество субъектов в кластере
  fviz_cluster(
    data = G_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```

### AGNES (несходство Брея - Кертиса)

-   с матрицей-дистанций с показателями несходства Брея --- Кертиса

```{r, message=FALSE, warning=FALSE}

agnes2 <- data_wide %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  vegdist(method = "bray") %>% #cоздаём матрицу дистанций, рассчитывая показатель несходства Брея — Кертиса (Bray-Curtis dissimilarity, 0 - полное совпадение пациентов по составу микробиоты, 1 - полное несовпадение 
  as.matrix() %>% 
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes2, 
          cex = 0.2, k = 3,
          rect = TRUE,
          k_colors = "jco",
          color_labels_by_k = FALSE,
          label_cols = ifelse (data_wide[agnes2$order,]$Health_state == "Health", "green", "red"),
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
  ylab = "Высота",)

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

fisher.test.simulate.p.values <- function(data, variable, by, ...) {
  result <- list()
  test_results <- stats::fisher.test(data[[variable]], data[[by]], simulate.p.value = TRUE)
  result$p <- test_results$p.value
  result$test <- test_results$method
  result
}

data_wide %>% 
  add_column("Cluster" = cutree(agnes2, k = 3)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p(test = list(all_categorical() ~ "fisher.test.simulate.p.values"))  # this applies the custom test to all categorical variables
 

```

## Кластеризация семейств (F-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 2 #количество кластеров

F_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_F")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- F_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes(
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Кластеризация субъектов по содержанию G-таксонов до коррекции batch-эффекта",
          ylab = "Высота")

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% #Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- F_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = F_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по F_таксонам")

```

### DBSCAN

-   определением оптимального размера радиуса (eps)

```{r}

F_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=25, col = "red", lty = 2)

```

```{r}

F_scaled %>%
dbscan::dbscan(eps = 25, # радиус
       minPts = 20) %>%  # мин. количество субъектов в кластере
  fviz_cluster(
    data = F_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```

## Кластеризация порядков (O-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 2 #количество кластеров

O_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_O")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- O_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes(
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% #Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- O_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = O_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по O_таксонам")

```

### DBSCAN

-   определением оптимального размера радиуса (eps)

```{r}

O_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=18, col = "red", lty = 2)

```

```{r}

O_scaled %>%
dbscan::dbscan(eps = 18, #радиус
       minPts = 20) %>%  #мин. количество субъектов в кластере
  fviz_cluster(
    data = O_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```

 

## Batch-effects correction

-   использовался пакет MBECS, пошаговое описание действий доступно по ссылке <https://github.com/rmolbrich/MBECS>

```{r, message=FALSE, warning=FALSE, include=FALSE}

#devtools::install_github("rmolbrich/MBECS")
#MBECS introductionhttps://bioconductor.org/packages/release/bioc/vignettes/MBECS/inst/doc/mbecs_vignette.html
library(MBECS)

#1. Get started
#Создание объекта класса MbecData
mbec.obj <- mbecProcessInput (
  list (
    #abundance table:
  combined_bacteria %>%
    select (!colnames (G_only_one) [- c (1,2)]) %>%  #удаление G_таксонов, которые обнаружены только в одном исследовании
    select (where (function(x) 
      sum (x != 0)/ nrow(.) * 100 >= 5)) %>% #выбор переменных, у которых менее 95% нули
    rename("sID" = "patient_ID") %>%
    mutate(sID = paste0 ("S", sID)) %>% 
    column_to_rownames('sID') %>% 
    as.data.frame(),
  
  #meta-data:
  combined_info %>%
    select (where (function(x) 
      sum (!is.na(x))/ nrow(.) * 100 >= 5)) %>% #выбор переменных, у которых менее 95% NA
    rename("sID" = "patient_ID") %>% 
    mutate(sID = as.character(sID),
           sID = paste0 ("S", sID),
           research_ID = as.factor(research_ID)) %>% 
    select (sID, everything()) %>% 
    as.data.frame()          
  ))


#2. Centered log-ratio transformation of the data
mbec.obj <- mbecTransform(mbec.obj, 
                          method = "clr",
                          offset = 0.0001) #смещение


#3. Preliminary report
#mbecReportPrelim(input.obj=mbec.obj, 
                 #model.vars=c('research_ID', 'Health_state'),
                 #model.vars=c (batch effect, presumed biological effect of interest)
                 #type="otu", #which abundance matrix to use for evaluation:  'cor'/'clr'/'tss'
                 #file.name = "Batch_Preliminary_Report_otu",
                 #file.dir = "data/originals/",
                 #return.data = FALSE)
                 
```

**Подготовлен Preliminary report (data/originals/).**

- сравнение batch-эффектов от research_ID и Seq_region по их процентному вкладу в вариацию данных

```{r, message=FALSE}

mbecModelVariance(
  input.obj=mbec.obj, 
  model.vars=c('research_ID', 'Health_state'),
  method="pvca",type="otu") %>% 
  mbecPVCAStatsPlot() 

mbecModelVariance(
  input.obj=mbec.obj, 
  model.vars=c('Seq_region', 'Health_state'),
  method="pvca",type="otu") %>% 
  mbecPVCAStatsPlot()

```


-   коррекция batch-эффекта (research_ID)

```{r, include=FALSE}

#Run corrections
mbec.obj <- mbecRunCorrections(
  mbec.obj, 
  model.vars=c('research_ID', 'Health_state'),
#model.vars=c (batch effect, presumed biological effect of interest) 
method = "bat", #batch effect correcting algorithm:
#Batch Mean Centering (bmc) /ComBat (bat)/Remove Batch Effect (rbe)
type = "otu") #which abundance matrix to use

#Post report
mbecReportPost(
  input.obj=mbec.obj, 
  model.vars=c('research_ID', 'Health_state'),
#model.vars=c (batch effect, presumed biological effect of interest) 
type="otu", # which abundance matrix to use for evaluation: clr/otu/tss
file.name = "Batch_(research_id)_Correction_Report_otu_bat",
file.dir = "data/originals/",
return.data = FALSE)

```

-   Извлечение скорректированных данных

```{r, message=FALSE, warning=FALSE}

library (datawizard)

#Retrieve corrrected data
ps.cor.bat <- mbecGetPhyloseq(mbec.obj, 
                          type="cor",
                          label="bat") #which type of data to add (correction)

combined_bacteria_batched <- ps.cor.bat@otu_table %>% 
  as.data.frame() %>% 
  data_rotate (rownames	= "patient_ID") %>% 
  mutate (patient_ID = sub ("S", "", patient_ID),
          patient_ID = as.numeric(patient_ID))

data_wide_batched <- combined_info %>% 
  select (where (function(x) 
      sum (!is.na(x))/ nrow(.) * 100 >= 5)) %>% #выбор переменных, у которых менее 95% NA
  left_join(combined_bacteria_batched)

rm (combined_bacteria_batched)
```

####Principal Component Analysis 

- Principal Component Analysis *до* коррекции batch-эффекта (research_ID)

```{r, message=FALSE, warning=FALSE, error=FALSE}

plot <- mbecPCA(input.obj=mbec.obj, 
        model.vars=c('research_ID', 'Health_state'),
        type="otu", pca.axes=c(1,2), return.data = FALSE) 

ggsave("data/pictures/PCA_befor_batching.jpeg", plot = plot)
```

- Principal Component Analysis *после* коррекции batch-эффекта (research_ID)

```{r, message=FALSE, warning=FALSE, error=FALSE}

plot <- mbecPCA(input.obj=mbec.obj, 
        model.vars=c('research_ID', 'Health_state'),
        type="cor", label = "bat",
        pca.axes=c(1,2), return.data = FALSE)  

ggsave("data/pictures/PCA_after_batching.jpeg", plot = plot)

```

####Heatmap

- Heatmap содержания 10-ти наиболее вариабельных таксонов *до* коррекции batch-эффекта (research_ID)

```{r}
mbecHeat(input.obj=mbec.obj, method = "TOP", n = 10, 
         model.vars=c('research_ID', 'Health_state'),
         center = TRUE, scale = TRUE, 
         type="otu",
         return.data = FALSE)

```

- Heatmap содержания 10-ти наиболее вариабельных таксонов *после* коррекции batch-эффекта (research_ID)

```{r}
mbecHeat(input.obj=mbec.obj, method = "TOP", n = 10, 
         model.vars=c('research_ID', 'Health_state'),
         center = TRUE, scale = TRUE, 
         type="cor", label = "bat", 
         return.data = FALSE)
```

## Кластеризация родов (G-таксонов) после коррекции batch-эффекта (research_ID)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 4 #количество кластеров

library(cluster)
library(factoextra)

G_scaled <- data_wide_batched %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- G_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide_batched[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Кластеризация субъектов по содержанию G-таксонов после batch-коррекции",
          ylab = "Высота")

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- G_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = G_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по содержанию G-таксонов до коррекции batch-эффекта")
      
```
               
### AGNES (несходство Брея --- Кертиса)

-   с матрицей-дистанций с показателями несходства Брея --- Кертиса

```{r, message=FALSE, warning=FALSE}

agnes2 <- data_wide_batched %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  vegdist(method = "bray") %>% #cоздаём матрицу дистанций, рассчитывая показатель несходства Брея — Кертиса (Bray-Curtis dissimilarity, 0 - полное совпадение пациентов по составу микробиоты, 1 - полное несовпадение 
  as.matrix() %>% 
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes2, 
          cex = 0.2, k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          color_labels_by_k = FALSE,
          label_cols = case_when (data_wide_batched[agnes2$order,]$Age_range == "> 43" ~ "red",
                                  data_wide_batched[agnes2$order,]$Age_range == "16-43" ~ "green",
                                  TRUE ~ "white"),
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

-   Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes2, k = clusters_number)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```


## data_wide (batched)
`
```{r}


data_wide <- data_wide_batched  

write_rds(data_wide, 
          file = "data/originals/data_wide.rds")

```

## bac_functions

-   загрузка и редактирование `bac_functions`

```{r}

# Чтение листов Excel-файла с функциями бактерий и их объединение
path <- "data/raw/Bacterial group functions.xlsx"
taxon <- c ("TaxonName", "Rank")

neuromediators <- read_xlsx (path, 2) %>% 
  mutate(Destroy = ifelse(is.na (Destroy), "produce", "destroy")) %>% 
  unique() %>%
  pivot_wider(names_from = Neuromediator, values_from = Destroy)

probiotics <- read_xlsx (path, 3) %>% 
  add_column(probiotics = 1)

special_properties <- read_xlsx (path, 4) %>% 
  add_column(special_properties = 1)

vitamins <- read_xlsx (path, 5) %>% 
  pivot_wider (names_from = Vitamin, values_from = Vitamin,
               values_fn = function(x) ifelse(is.na (x), NA, 1))

habbits <- read_xlsx (path, 7) %>%
  unique() %>% #удаление повторяющихся строк 
  pivot_wider(names_from = Habbit, values_from = Habit_state)

bac_functions <- read_xlsx (path, 1) %>% #Патогены и нежелательные
  full_join(neuromediators, by = taxon) %>% #Нейромедиаторы
  full_join(probiotics, by = taxon) %>% #Пробиотики
  full_join(special_properties, by = taxon) %>% #С особыми свойствами
  full_join(vitamins, by = taxon) %>%  #Витамины
  full_join(read_xlsx (path, 6), by = taxon) %>% #Продуценты КЦДК
  full_join(habbits, by = taxon) %>% #Вредные привычки
  
  unite("Taxon", TaxonName, Rank, sep = "_") %>% 
  filter (Taxon != "Blautia obeum_S") %>% #для данного таксона противоречивая информация в Продуценты КЦЖК
  mutate_all(as.factor)

rm (path, taxon, neuromediators, probiotics, special_properties, vitamins, habbits)
```

## data_long

-   Перевод `data_wide` в длинный формат (`data_long`), объединение `data_long` и `bac_functions`

```{r data_long, warning=FALSE}

# Создание датасета в длинном формате
data_long <- data_wide %>% 
  pivot_longer(ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")),
               names_to = "Taxon", values_to = "Percentage")

#Перезапись data_long с добавлением функций бактерий
data_long <- data_long %>% 
  left_join (bac_functions, by = "Taxon")

#Сохранение data_long.rds
write_rds(data_long, 
          file = "data/originals/data_long.rds",
          compress = "gz") 

```

-   Создание отдельных длинных датасетов для каждого таксона

```{r}

G_long <- data_long %>% subset(grepl("_G", Taxon)) 
# %>% select (where (function(x) sum (is.na(x))/ nrow(.) * 100 < threshold_percent))
F_long <- data_long %>% subset(grepl("_F", Taxon))
C_long <- data_long %>% subset(grepl("_C", Taxon))
O_long <- data_long %>% subset(grepl("_O", Taxon))
P_long <- data_long %>% subset(grepl("_P", Taxon))

write_rds(G_long, 
          file = "data/originals/G_long.rds", "gz") 
write_rds(F_long, 
          file = "data/originals/F_long.rds", "gz") 
write_rds(C_long, 
          file = "data/originals/C_long.rds", "gz") 
write_rds(O_long, 
          file = "data/originals/O_long.rds", "gz") 
write_rds(P_long, 
          file = "data/originals/P_long.rds", "gz") 

```

# Анализ

## Факторный анализ

-   Проведем множественное сравнение каждого таксона из `combined_bacteria` с по группе `Health_state` из `combined_info` без учета таксономического уровня.

```{r}
# Создание нового датасета для сохранения результатов
result_dataset <- data.frame(
  Variable_Name = character(),
  Test_Type = character(),
  P_Value = numeric(),
  Normal_Distribution = character(),
  stringsAsFactors = FALSE
)

alpha = 0.05

# Объединяем датасеты по patient_id 
combined_data <- data_wide %>%
  select(Health_state,
    ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")))

combined_bacteria_clean <- combined_data

# Получаем список переменных из датасета combined_bacteria, исключая "patient_ID"
values_to_exclude <- c("patient_ID", "Seq_date", "Age")
variable_names <- setdiff(names(combined_bacteria_clean), values_to_exclude)

# Проходим по каждой переменной
for (variable in variable_names) {
  # Фильтрация данных (исключаем строки с NA и 0 в текущей переменной)
  filtered_data <- combined_data[!is.na(combined_data[[variable]]) & combined_data[[variable]] != 0, ]
  #print(variable)
  #print(filtered_data)

  # Проверим что датасет filtered_data не пустой и что количество групп сравнения более 1, в нашем случае их 2 :)
  if (nrow(filtered_data) > 0 & length(unique(filtered_data$Health_state)) > 1) {
    
  # Check if there is sufficient variability in the data
  if (length(unique(filtered_data$Health_state)) > 1) {
    # Проверка на нормальность
    shapiro_test_result <- try(shapiro.test(filtered_data[[variable]]), silent = TRUE)
    if (inherits(shapiro_test_result, "try-error")) {
      warning(paste("Skipping Shapiro-Wilk test for variable", variable, "due to an error."))
      next
    }
    p_value_shapiro <- shapiro_test_result$p.value

    # Выбор соответствующего статистического теста
    if (p_value_shapiro > 0.05) {
      # Если нормальное распределение, провести дисперсионный анализ
      model <- aov(filtered_data[[variable]] ~ Health_state, data = filtered_data)
      summary_list <- summary(model)
      test_type <- "ANOVA"
    } else {
      # Если не нормальное распределение, использовать тест Краскела-Уоллиса
      tryCatch({
        model <- kruskal.test(filtered_data[[variable]] ~ Health_state, data = filtered_data)
        test_type <- "Kruskal-Wallis"
      }, error = function(e) {
        warning(paste("Skipping Kruskal-Wallis test for variable", variable, "due to an error:", conditionMessage(e)))
        next
      })
    }

    # Добавление результатов выбранного теста в датасет
    result_dataset <- rbind(result_dataset, 
                            data.frame(Variable_Name = variable,
                                       Test_Type = test_type,
                                       P_Value = ifelse(test_type == "ANOVA", summary_list[[1]]$"Pr(>F)"[1], model$p.value),
                                       Normal_Distribution = ifelse(p_value_shapiro > 0.05, "Yes", "No")))
  } else {
    # If there is no variability, skip the tests
    warning(paste("Skipping tests for variable", variable, "as there is not enough variability in the data."))
  }
  }}

# Добавление столбца с поправкой Бонферрони
result_dataset$Adjusted_P_Value_Bonferroni <- p.adjust(result_dataset$P_Value, method = "bonferroni")

# Добавление столбца с поправкой Холма
result_dataset$Adjusted_P_Value_Holm <- p.adjust(result_dataset$P_Value, method = "holm")

# Добавление столбца с поправкой Бенджамини-Хохберга
result_dataset$Adjusted_P_Value_BH <- p.adjust(result_dataset$P_Value, method = "BH")

result_dataset$test_pass = ifelse(result_dataset$Adjusted_P_Value_Bonferroni < alpha & result_dataset$Adjusted_P_Value_Holm < alpha & result_dataset$Adjusted_P_Value_BH < alpha, "Y", "N")

result_dataset_pass <- result_dataset %>% filter(test_pass == "Y")

# Вывод результатов
print(result_dataset_pass)

```

-   Посмотрим на данные здоровых людей и людей с СРК как на многомерный вектор по всем таксонам и группам

```{r, warning=FALSE}

combined_bacteria_G <- combined_bacteria_clean %>%
  select(Health_state, ends_with("_G"))

d <- dist(combined_bacteria_G) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim

df_mds <- data.frame(
  x = fit$points[,1],
  y = fit$points[,2]
  )  

df_full <- cbind(df_mds, combined_info) %>% mutate(Health_state_n = case_when(Health_state == "Health"  ~ 0,
                                                                              Health_state == "Disease" ~ 1))

ggplot(df_full, aes(x = x, y = y, color = Health_state)) +
  geom_point() +
  theme_bw() +
  ggtitle("Распределение вектора таксонов в зависимости от группы пациентов")
```

-   Используя метод пермутаций проверим отличаются ли группы в зависимомти от Health_state

```{r permanova}

adonis2(d ~ Health_state_n, data = df_full)

```

## Тест Манна-Уитни для сравнения каждого таксона между больными и здоровыми

-   после округления всех значений **до целого**

```{r}

Wilcox_comparison_round_0 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,0))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_0),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_0 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_0 %>% filter (p_value_BH <= 0.05 ))
 )
 
```

-   после округления всех значений **до десятых**

```{r}

Wilcox_comparison_round_1 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,1))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_1),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_1 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_1 %>% filter (p_value_BH <= 0.05 ))
 )
 
```

-   после округления всех значений **до сотых**

```{r}

Wilcox_comparison_round_2 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,2))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_2),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_2 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_2 %>% filter (p_value_BH <= 0.05 ))
 )
 
```
## GLM метод для нулей

```{r labels for Tweedie GLM model, message=FALSE}

library("haven")
library("ResourceSelection")  ## Package to perform the Hosmer-Lemeshow GOF test
library("survey")
library("prediction")
library("margins")
library("ggeffects")
library("sjPlot")
library("statmod")
#devtools::install_github("strengejacke/strengejacke")
#install.packages(c("haven", "ResourceSelection", "survey", "prediction", "margins", "ggeffects", "sjPlot", "statmod"))

```

```{r}
options(survey.lonely.psu = 'adjust')
start_values <- c(0, 0, 1)
```

## G - Genus (Род)
```{r warning=FALSE}

analyze_taxon <- function(taxon_name, data) {
  tryCatch(
    {
      data_filtered <- data %>%
        filter(Taxon == taxon_name) %>%
        select(patient_ID, Health_state, Percentage, Age_range, research_ID) %>%
        mutate(Health_state_num = ifelse(Health_state == "Health", 0, 1)) # для упрацения интерпритации процентов
      
      mepsdsgn = svydesign(
        id = ~patient_ID,
        strata = ~research_ID,
        weights = NULL,
        data = data_filtered,
        nest = TRUE)
      
      start_values <- c(0, 0, 1)
      
      model <- svyglm(Percentage ~ Health_state_num + research_ID,
                      mepsdsgn,
                      family = tweedie(var.power = 2, link.power = 1),
                      start = start_values)
      
      summary_table <- summary(model)
      
      tidy_output <- tidy(model)
      
      result_table1 <- tidy_output %>%
        filter(term == "Health_state_num") %>%
        select(estimate, p.value)
      
      result_table2 <- as.data.frame(confint(model)["Health_state_num", ])
      
      result_table2_transposed <- t(result_table2)
      
      final_result_table_transposed <- bind_cols(result_table1, result_table2_transposed) %>%
        select(estimate, `2.5 %`, `97.5 %`, p.value)
      
      final_result_table_transposed$Taxon <- taxon_name
      
      return(final_result_table_transposed)
    },
    error = function(e) {
      # Обработка ошибки (можно добавить сообщение или просто вернуть NULL)
      # cat("Error in analyze_taxon for Taxon:", taxon_name, "\n")
      return(NULL)
    }
  )
}

# Применение функции ко всем таксонам
unique_taxa <- unique(G_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, G_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_G <- final_result_df %>%
  filter(p.adjusted < 0.05)

 #install.packages("knitr")
 #install.packages("kableExtra")

# Загрузка библиотек
library(knitr)
library(kableExtra)

# Ваш код

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_G, "html") %>%
  kable_styling(full_width = F)
```
## Распределения таксонов G(Genus - Род)

#### Гистограмма по количеству пациентов (Здоров - СРК)


```{r}
create_and_plot_taxon_groups <- function(filter_pattern, step_size, dataset_name) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим графики
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    current_dataset <- get(dataset_name)  # Получаем датасет по его имени
    
    G_long_filtered <- current_dataset %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0) %>%
      group_by(Health_state, Taxon) %>%
      summarise(Count = n(), .groups = "drop")
    
    bar_plot <- ggplot(G_long_filtered, aes(x = Health_state, y = Count, fill = Health_state == "Disease")) +
      geom_bar(position = "dodge", color = "black", stat = "identity") +
      scale_fill_manual(values = c("skyblue", "red"), guide = FALSE) +
      labs(title = paste("Гистограмма для таксонов", (i - 1) * step_size + 1, "до", min(i * step_size, nrow(unique_taxa)), "в разрезе Health_state"),
           x = "Статус пациента",
           y = "Количество пациентов, у которых обнаружен данный таксон") +
      coord_flip() +
      facet_wrap(~Taxon, scales = "free_y", ncol = 2, shrink = 0.7) +  # Уменьшение пространства между фасетами
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),  # Поворот текста на оси X и уменьшение шрифта
            axis.text.y = element_text(hjust = 1, size = 5),
            strip.text = element_text(size = 5))  # Уменьшение шрифта для названия фасет
    
    print(bar_plot)  # Отображение графика на экране
    
  }
}

# Пример вызова функции с передачей "_G" в качестве аргумента и названия датасета "G_long"
create_and_plot_taxon_groups("_G", 18, "G_long")

```

### график солнышко

```{r}
create_and_plot_circular_diagrams <- function(dataset, filter_pattern, step_size, filename) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим графики
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    G_long_filtered <- dataset %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0) %>%
      group_by(Health_state, Taxon) %>%
      summarise(Count = n(), .groups = "drop")
    
    # Добавляем строки с Count = 0 для всех комбинаций Health_state и Taxon
    G_long_filtered <- G_long_filtered %>%
      complete(Health_state, Taxon, fill = list(Count = 0))
    
    data_id <- G_long_filtered %>% filter(G_long_filtered$Health_state == "Disease") %>%
      mutate(id = row_number()) %>% 
      select(Taxon, id)
    
    G_long_filtered <- left_join(G_long_filtered, data_id, by = "Taxon")
    
    labels_data <- G_long_filtered %>% filter(Health_state == "Disease")
    number_of_bars <- nrow(labels_data)
    
    #Вычислим углы для лейбла каждого барра
    labels_data$angel <- 90 - 360 * (labels_data$id-0.5) / number_of_bars
    
    # Добавим горизонтольную регулировку
    labels_data <- labels_data %>%
      mutate(hjust = ifelse(angel < -90, 1, 0))
    
    # Перевернем лейбл в зависимости от "полушария"
    labels_data <- labels_data %>%
      mutate(angel = ifelse(angel < -90, angel + 180, angel))
    
    # Круговая диаграмма для объединенного датасета
    p <- ggplot(data = G_long_filtered, mapping = aes(x = id, y = Count, fill = Health_state)) + 
      geom_bar(stat = "identity", position = "stack") + 
      ylim(-150, 500) +
      
      # Добавляем кастомную тему
      theme_minimal(base_size = 8) +
      theme(axis.text   = element_blank(),
            axis.title  = element_blank(),
            panel.grid  = element_blank(),
            plot.margin = unit(rep(-1, 6), "cm")) +
      coord_polar(start = 0)+
      geom_text(data = labels_data,
                aes(x = id, y = Count,
                    label = Taxon,
                    hjust = hjust),
                color = "black",
                fontface = "bold",
                alpha = 0.9,
                size = 1.5,
                angle = labels_data$angel,
                inherit.aes = FALSE) +
      # Добавляем горизонтальные линии сетки
      geom_hline(yintercept = seq(0, 300, by = 50),
                 linetype = "dotted",
                 color = "gray",
                 size = 0.5) +
      # Добавляем значения рядом с линиями сетки
      annotate("text", x = 1.2, y = seq(0, 300, by = 50),
               label = seq(0, 300, by = 50),
               color = "black",
               size = 3,
               alpha = 40,
               hjust = 0)
    
    p <- p + annotate("text", x = 0.5, y = 490, label = "Сотношение здоровых пациентов и пациентов с СРК",
                      size = 5, color = "black", fontface = "bold", hjust = 0.5)
    
    # Сформируем имя файла для сохранения
    current_filename <- paste0(filename, "_", i, ".png")
    
    # Сохраняем график под уникальным именем
    ggsave(current_filename, p, width = 10, height = 8)
    
    print(p)
  }
}

# Пример вызова функции
create_and_plot_circular_diagrams(G_long, "_G", 40, "output_plot")

```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots <- function(G_long, filter_pattern, step_size, x_var, title) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим боксплоты
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    G_long_filtered <- G_long %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0)
    
    # Создаем формулу для переменной x_var
    formula <- as.formula(paste("Age ~", x_var))
    
    # Строим боксплот
    box_plot <- ggplot(G_long_filtered, aes_string(x = x_var, y = "Age", fill = "Health_state")) +
      geom_boxplot() +
      labs(title = paste(title),
           x = x_var,
           y = "Age") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Уменьшаем размер шрифта для подписей Taxon
            axis.title.x = element_blank(),  # Убираем название оси X
            legend.position = "bottom") +  # Перемещаем легенду вниз
      scale_fill_manual(values = c("red", "skyblue")) +
      facet_grid(~Taxon, scales = "free_y", space = "free")  # Используем facet_grid вместо facet_wrap
    
    # Отображаем график на экране
    print(box_plot)
  }
}

# Пример вызова функции с Health_state в качестве x_var
create_and_plot_boxplots(G_long, "_G", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")

```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```


## Распределения таксонов F Family(семейство)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_F", 18, "F_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(F_long, "_F", 40, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(F_long, "_F", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```


### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов C - Class (класс)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_C", 18, "C_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(C_long, "_C", 40, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(C_long, "_C", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```


### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов O - Order (порядок)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_O", 18, "O_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(O_long, "_O", 30, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(O_long, "_O", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```


### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```


## Распределения таксонов P - Phylum (тип)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_P", 18, "P_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(P_long, "_P", 30, "P_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(P_long, "_P", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```


### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```


## Посмотрим на данные здоровых людей и людей с СРК как на многомерный вектор по всем таксонам и группам

## G - Genus 

```{r}
perform_permutation_test <- function(data, filter_pattern) {
  
  combined_bacteria_G <- data %>%
    select(Health_state, ends_with(filter_pattern))
  
  d <- dist(combined_bacteria_G) # euclidean distances between the rows
  fit <- cmdscale(d, eig=TRUE, k=2) # k is the number of dim
  
  df_mds <- data.frame(
    x = fit$points[,1],
    y = fit$points[,2]
  )  
  
  df_full <- cbind(df_mds, combined_info) %>% 
    mutate(Health_state_n = case_when(Health_state == "Health"  ~ 0,
                                      Health_state == "Disease" ~ 1))
  
  msd_plot <- ggplot(df_full, aes(x = x, y = y, color = Health_state)) +
    geom_point() +
    theme_bw() +
    ggtitle("Распределение вектора таксонов в зависимости от группы пациентов")
  
  print(msd_plot)
  
  print("Используя метод пермутаций проверим отличаются ли группы в зависимости от Health_state")
  
  adonis2(d ~ Health_state_n, data = df_full)
}

# Пример вызова функции с использованием другого фильтра
perform_permutation_test(combined_bacteria_clean, "_G")
```

## F - Family (семейство)

```{r}
perform_permutation_test(combined_bacteria_clean, "_F")
```

## C - Class (класс)

```{r}
perform_permutation_test(combined_bacteria_clean, "_C")
```

## O - Order (порядок)

```{r}
perform_permutation_test(combined_bacteria_clean, "_O")
```

## P - Phylum (тип)

```{r}
perform_permutation_test(combined_bacteria_clean, "_P")
```

# Кластеризация

## Кластеризация родов (G-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 4 #количество кластеров

library(cluster)
library(factoextra)

G_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- G_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

- Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- G_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = G_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по G-таксонам")

```


### Определение оптимального количества кластеров 

- методом локтя

```{r}

G_scaled %>% 
fviz_nbclust(FUN = hcut, method = "wss") 

```

- с помощью коэффициента силуэта 

```{r}

G_scaled %>% 
  fviz_nbclust(FUN = hcut, method = "silhouette") 

```

### DBSCAN

- определением оптимального размера радиуса (eps) 

```{r}

G_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=37, col = "red", lty = 2)

```


```{r}

G_scaled %>%
dbscan::dbscan(eps = 37, # радиус
       minPts = 20) %>%  # мин. количество субъектов в кластере
  fviz_cluster(
    data = G_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```
### AGNES (agglomerative clustering)

- с матрицей-дистанций с показателями несходства Брея — Кертиса

```{r, message=FALSE, warning=FALSE}

agnes2 <- data_wide %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  vegdist(method = "bray") %>% #cоздаём матрицу дистанций, рассчитывая показатель несходства Брея — Кертиса (Bray-Curtis dissimilarity, 0 - полное совпадение пациентов по составу микробиоты, 1 - полное несовпадение 
  as.matrix() %>% 
  agnes( #выбираем Agglomerative clustering (иерархическая кластеризация снизу вверх)
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes2, 
          cex = 0.2, k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          color_labels_by_k = FALSE,
          label_cols = ifelse (data_wide[agnes2$order,]$Health_state == "Health", "green", "red"),
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
  ylab = "Высота",)

```
- Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes2, k = clusters_number)) %>% # Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

## Кластеризация семейств (F-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 2 #количество кластеров

F_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_F")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- F_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes(
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

- Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% #Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- F_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = F_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по F_таксонам")

```

### DBSCAN

- определением оптимального размера радиуса (eps) 

```{r}

F_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=25, col = "red", lty = 2)

```

```{r}

F_scaled %>%
dbscan::dbscan(eps = 25, # радиус
       minPts = 20) %>%  # мин. количество субъектов в кластере
  fviz_cluster(
    data = F_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```

## Кластеризация порядков (O-таксонов)

### AGNES (agglomerative clustering)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 2 #количество кластеров

O_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_O")) %>% #выбираем только G-таксоны
  scale () #нормируем данные

agnes <- O_scaled %>% 
  dist (method = "euclidean") %>% #cоздаём матрицу дистанций
  as.matrix() %>%  
  agnes(
    diss = TRUE, #на вход подана dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),#цвет лейблов определяется по Health_state
          cex = 0.2, #размер шрифта лейблов
          main = "Дендрограмма кластеризации субъектов по количеству G-таксонов",
          ylab = "Высота")

```

- Сравнение полученных кластеров по основным переменным

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% #Создаём новый столбец - вектор принадлежности к кластерам  
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### kMeans

```{r}

kmeans <- O_scaled %>% 
  kmeans(centers = clusters_number, # Кол-во кластеров
         iter.max = 20, # Максимальное кол-во итераций
         nstart = 35) # Кол-во центройдов в начале

  fviz_cluster(kmeans,data = O_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "Кластеризация субъектов по O_таксонам")

```

### DBSCAN

- определением оптимального размера радиуса (eps) 

```{r}

O_scaled %>% 
dbscan::kNNdistplot(minPts = 20)  # мин. количество субъектов в кластере

abline(h=18, col = "red", lty = 2)

```


```{r}

O_scaled %>%
dbscan::dbscan(eps = 18, #радиус
       minPts = 20) %>%  #мин. количество субъектов в кластере
  fviz_cluster(
    data = O_scaled, 
    stand = TRUE,
    ellipse = FALSE, 
    show.clust.cent = FALSE,
    geom = "point", 
    palette = "jco", 
    ggtheme = theme_classic())

```

```{r}
#test commit
```

