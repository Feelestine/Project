---
title: "Project"
author: "Olga Potanina"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(openxlsx)
library (tidyverse)
library(vegan)
library(dplyr) 
library(tidyr) 
library(broom) 
```

## Чтение, слияние, редактирование исходных датасетов

-   Загрузка датасетов с информацией о здоровых людях (`info_healthy`) и пациентах с СРК (`info_ibs`)

```{r, message=FALSE}

info_healthy <- read_xlsx ("data/raw/final_health_statistic.xlsx")
info_ibs <- read_xlsx ("data/raw/final_ibs_141_statistic.xlsx")

```

-   Сравнение переменных в `info_healthy` и `info_ibs`

```{r, echo=FALSE}

cat (
c ("Уникальные переменные в info_ibs:", info_ibs %>% 
  select (- c (intersect (names(info_healthy), names(info_ibs)))) %>% colnames()),
c ("Уникальные переменные в info_healthy:", info_healthy %>% 
  select (- c (intersect (names(info_ibs), names(info_healthy)))) %>% colnames()), 
sep = "\n") 

```

-   Объединение `info_healthy` и `info_ibs` в единый датасет `combined_info` c редактированием содержимого

```{r combined_info, message=FALSE}

combined_info <- info_healthy %>% 
  bind_rows(info_ibs) %>%
  mutate (
    BMI_min = ifelse (is.na (BMI_min), round (Weight_min /(Height_max/100 * Height_max/100), 2), BMI_min),
    BMI_max = ifelse (is.na (BMI_max), round (Weight_max /(Height_min/100 * Height_min/100), 2), BMI_max)
    ) %>% 
  unite("BMI_range", BMI_min, BMI_max, sep = "-", na.rm = TRUE) %>%
  unite ("Age_range", Age_min, Age_max, sep = "-", na.rm = TRUE) %>%
  mutate(
    research_ID = sub ("research_", "", research_ID),
    patient_ID = row_number(),
    Sex = ifelse (Sex == "mixed", NA, Sex),
    Smoking = sub ("never", "Never",  Smoking),
    Alcohol = sub ("rarely", "Rarely", Alcohol),
    Hygiene = case_when(
      Hygiene == "Occasionally (1-2 times/week) cosmetics" ~ "Occasionally cosmetics (1-2 times/week)",
      Hygiene == "Rarely (a few times/month) cosmetics" ~ "Rarely cosmetics (a few times/month)",
      TRUE ~ Hygiene),
    Physical_activity = sub ("regularly", "Regularly",  Smoking),
    BMI = ifelse (is.na(Weight_kg), BMI, Weight_kg/ (Height_cm/100 * Height_cm/100)),
    BMI_range = ifelse(BMI_range == "", NA, BMI_range),
    BMI_category = case_when(
      BMI_range == "18-25" ~ "normal/overweight",
      BMI_range == "19.21-29.29" ~ "normal/overweight",
      BMI_range == "20.6-29.6" ~ "normal/overweight",
      BMI_range == "21.74-28.38" ~ "normal/overweight",
      BMI_range == "18.5-30.8" ~ "normal/overweight", #немного больше 30
      BMI < 18.5 ~ "underweight",
      BMI >= 18.5 & BMI < 30 ~ "normal/overweight",
      BMI >= 30 ~ "obese")
    ) %>% 
  mutate_if (is.character, as.factor) %>% 
  select(-c(
    Instrument, # unique (combined_info$Instrument) = "Illumina MiSeq" 
    Isolation_source, # unique (combined_info$Isolation_source) = "faeces" 
    Assay_type, # unique (combined_info$Assay_type) = "AMPLICON"
    Target_gene, # unique (combined_info$Target_gene) = "16S"
    Main_Disease, # unique (combined_info$Main_Disease) = NA (for healthy), 141 (for ibs)
    Drugs, # unique (combined_info$Drugs) = NA
    Social_status, # unique (combined_info$Social_status) =  NA, urban 
    Weight_kg, Height_cm, Weight_min, Weight_max, Height_min, Height_max, BMI_range, #использованы для создания BMI_category, уменьшения количества NA в BMI
    Birth_Year, # имеются значения только в тех случаях, где возраст уже известен
    Age_range) # unique (combined_info$Age_range))) = 18-40, 23-28, 16-42, 21-43, 28-54
  )

rm (info_healthy, info_ibs)

summary (combined_info)

```

```{r}

library(gtsummary)
combined_info %>% 
  select(-patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(1, 1),
                                 all_categorical() ~ c(0, 1)),
              by = Health_state) %>%
  add_p()

```

-   Загрузка датасетов с данными о микробиоме здоровых людей (`bacteria_healthy`) и пациентов с СРК (`bacteria_ibs`) и их объединение в `combined_bacteria`

```{r combined_bacteria, message = FALSE}

bacteria_healthy <- read_csv("data/raw/final_bacteria_health.csv")
bacteria_ibs <- read_csv("data/raw/final_bacteria_ibs_141.csv")

combined_bacteria <- bacteria_healthy %>% 
  bind_rows (bacteria_ibs) %>% 
  mutate(patient_ID = row_number())

rm (bacteria_healthy, bacteria_ibs)

```

-   Объединение `combined_bacteria` и `combined_info` в `final_data_wide`

```{r final_data_wide, message=FALSE}

final_data_wide <- combined_info %>% 
  bind_cols(combined_bacteria) %>% 
  rename(patient_ID = patient_ID...2) %>% 
  mutate(patient_ID...24 = NULL)

```

## Оценка доли NA и нулевых значений

-   Оценка доли NA в переменных `final_data_wide`

```{r}

final_data_wide %>% 
  select (where (function(x) sum (is.na(x))/ nrow(final_data_wide) * 100 > 0)) %>% 
  sapply (function(x) sum (is.na(x))/ nrow(final_data_wide) * 100) %>% round(1) %>% 
  as.data.frame() %>% 
  rename(NA_percentage = ".") %>% 
  mutate (
    "Number of people with known data" = round (nrow(final_data_wide) - NA_percentage/100 * nrow(final_data_wide)),
    NA_percentage = paste (NA_percentage, "%", sep = " ")
    ) %>% 
  arrange(desc (NA_percentage)) %>% 
  rownames_to_column() %>% 
  as_tibble() %>% flextable::flextable()

```

-   Рассчитаем процент не NA и не 0 данных по колонкам широкого формата

```{r calculate percentage for each variable}

# Устанавливаем порог процента 
threshold_percent <- 95 
 
# Функция для вычисления процента записей, не равных NA и не равных 0, для каждой колонки 
calculate_percentage <- function(col) { 
  sum(!is.na(col) & col != 0) / length(col) * 100 
} 
 
# Применяем функцию к каждой колонке в датасете 
percentage_non_zero_non_na <- sapply(final_data_wide[, -1], calculate_percentage) 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  column = names(percentage_non_zero_non_na), 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% 
  arrange(desc(percentage))
 
# Отфильтровываем колонки, у которых процент записей менее threshold_percent% 
filtered_columns <- result_df_sort[result_df_sort$percentage < threshold_percent, ]

# Сохраним датасет в excel для дальнейшего анализа
write.xlsx(filtered_columns, 
           file = "data/originals/percentage_by_vars.xlsx")

# Перезапись final_data_wide с выбором колонок с процентом NA/0 менее threshold_percent 
final_data_wide <- final_data_wide %>% 
  select (row.names(filtered_columns), research_ID)

rm (calculate_percentage, result_df_sort)

```

-   Рассчитаем процент не NA и не 0 данных по форматированному `patient_ID`

```{r}
# Устанавливаем порог процента 
threshold_percent <- 95
 
# Рассчитываем процент значений, не являющихся NA и не равных 0, для каждого пациента 
percentage_non_zero_non_na <- rowMeans(!is.na(final_data_wide) & final_data_wide != 0, na.rm = TRUE) * 100 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  patient_id = final_data_wide$patient_ID, 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% arrange(desc(percentage))

# Отфильтровываем пациентов, у которых процент значений менее threshold_percent% 
filtered_patients <- result_df_sort[result_df_sort$percentage < threshold_percent, ] 

# Сохраним датасет в excel для дальнейшего анализа 
write.xlsx(filtered_patients,
           file = "data/originals/percentage_by_patient.xlsx") 

# Перезапись final_data_wide с удалением строк с процентом NA/0 более threshold_percent 
final_data_wide <- final_data_wide %>% 
  slice (filtered_patients$patient_id) #при threshold_percent = 95%, изменения final_data_wide не происходит, так как нет пациентов с процентом NA/0 более 95%

rm (percentage_non_zero_non_na, result_df_sort)

```

-   Сохранение `final_data_wide` после удаления колонок и строк с процентом NA/0 более threshold_percent

```{r}
final_data_wide <- 
  final_data_wide %>% 
  select (patient_ID, any_of (colnames(combined_info)), everything()) %>% 
  arrange(patient_ID)

write_rds(final_data_wide, 
          file = "data/originals/final_data_wide.rds")

```

-   Перевод `final_data_wide` в длинный формат (`final_data_long`)

```{r final_data_long}

final_data_long <- final_data_wide %>% 
  pivot_longer(ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")),
               names_to = "Taxon", 
               values_to = "Percentage")

write_rds(final_data_long, 
          file = "data/originals/final_data_long.rds",
          compress = "gz" ) 
#final_data_long не загружается на GitHub (слишком большой), поэтому был сжат

```

## Факторный анализ

-   Проведем множественное сравнение каждого таксона из `combined_bacteria` с по группе `Health_state` из `combined_info`

```{r}
# Создание нового датасета для сохранения результатов
result_dataset <- data.frame(
  Variable_Name = character(),
  Test_Type = character(),
  P_Value = numeric(),
  Normal_Distribution = character(),
  stringsAsFactors = FALSE
)

# Сохранение названий переменных, где все наблюдения 0 или NA
removed_variables <- colnames(combined_bacteria)[apply(combined_bacteria, 2, function(x) all(is.na(x) | x == 0))]
cat("Removed Variables:", toString(removed_variables), "\n")

# Удаление переменных из combined_bacteria
combined_bacteria_clean <- combined_bacteria[, !colnames(combined_bacteria) %in% removed_variables]

colnames(combined_bacteria_clean) <- gsub(" ", "_", colnames(combined_bacteria_clean))
colnames(combined_bacteria_clean) <- gsub("-", "_", colnames(combined_bacteria_clean))

# Объединяем датасеты по patient_id 
combined_data <- left_join(combined_bacteria_clean, combined_info, by = "patient_ID") 

# Получаем список переменных из датасета combined_bacteria, исключая "patient_ID"
variable_names <- setdiff(names(combined_bacteria_clean), "patient_ID")

# Проходим по каждой переменной
for (variable in variable_names) {
  # Фильтрация данных (исключаем строки с NA и 0 в текущей переменной)
  filtered_data <- combined_data[!is.na(combined_data[[variable]]) & combined_data[[variable]] != 0, ]
  #print(variable)
  #print(filtered_data)

  # Проверим что датасет filtered_data не пустой и что количество групп сравнения более 1, в нашем случае их 2 :)
  if (nrow(filtered_data) > 0 & length(unique(filtered_data$Health_state)) > 1) {
    
  # Check if there is sufficient variability in the data
  if (length(unique(filtered_data$Health_state)) > 1) {
    # Проверка на нормальность
    shapiro_test_result <- try(shapiro.test(filtered_data[[variable]]), silent = TRUE)
    if (inherits(shapiro_test_result, "try-error")) {
      warning(paste("Skipping Shapiro-Wilk test for variable", variable, "due to an error."))
      next
    }
    p_value_shapiro <- shapiro_test_result$p.value

    # Выбор соответствующего статистического теста
    if (p_value_shapiro > 0.05) {
      # Если нормальное распределение, провести дисперсионный анализ
      model <- aov(filtered_data[[variable]] ~ Health_state, data = filtered_data)
      summary_list <- summary(model)
      test_type <- "ANOVA"
    } else {
      # Если не нормальное распределение, использовать тест Краскела-Уоллиса
      tryCatch({
        model <- kruskal.test(filtered_data[[variable]] ~ Health_state, data = filtered_data)
        test_type <- "Kruskal-Wallis"
      }, error = function(e) {
        warning(paste("Skipping Kruskal-Wallis test for variable", variable, "due to an error:", conditionMessage(e)))
        next
      })
    }

    # Добавление результатов выбранного теста в датасет
    result_dataset <- rbind(result_dataset, 
                            data.frame(Variable_Name = variable,
                                       Test_Type = test_type,
                                       P_Value = round(ifelse(test_type == "ANOVA", summary_list[[1]]$"Pr(>F)"[1], model$p.value), 4),
                                       Normal_Distribution = ifelse(p_value_shapiro > 0.05, "Yes", "No")))
  } else {
    # If there is no variability, skip the tests
    warning(paste("Skipping tests for variable", variable, "as there is not enough variability in the data."))
  }
}}

# Вывод результатов
print(result_dataset)

```

-   Посмотрим на данные здоровых людей и людей с СРК как на многомерный вектор по всем таксонам и группам

```{r}

d <- dist(combined_bacteria) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim

df_mds <- data.frame(
  x = fit$points[,1],
  y = fit$points[,2]
  )  

df_full <- cbind(df_mds, combined_info) %>% mutate(Health_state_n = case_when(Health_state == "Health"  ~ 0,
                                                                              Health_state == "Disease" ~ 1))

ggplot(df_full, aes(x = x, y = y, color = Health_state)) +
  geom_point() +
  theme_bw() +
  ggtitle("Распределение вектора таксонов в зависимости от группы пациентов")
```

-   Используя метод пермутаций проверим отличаются ли группы в зависимомти от Health_state

```{r permanova}

adonis2(d ~ Health_state_n, data = df_full)

```
